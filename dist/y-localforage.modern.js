import*as t from"yjs";import{Observable as e}from"lib0/observable";class s extends e{constructor(t,e,s=500,i){super(),this._Store=void 0,this._sharedDoc=void 0,this._SuperProvider=void 0,this._isBusy=!1,this._UpdateLimit=500,this._pendingUpdates=0,this._completedUpdates=0,this._enqueuedUpdates=[],this._SubDocMap=new Map,this._Store=t,this._sharedDoc=e,this._SuperProvider=i,this._isBusy=!1,this._UpdateLimit=s,this._storeUpdate=this._storeUpdate.bind(this),e.on("update",this._storeUpdate),this._manageSubDocs=this._manageSubDocs.bind(this),e.on("subdocs",this._manageSubDocs),this.destroy=this.destroy.bind(this),e.on("destroy",this.destroy),this._applyStoredUpdates()}get isSynced(){return 0===this._pendingUpdates}get isFullySynced(){return 0===this._pendingUpdates&&Array.from(this._SubDocMap.values()).every(t=>t.isSynced)}SubDocIsSynced(t){const e=this._SubDocMap.get(t);return null!=e&&e.isSynced}async destroy(){if(null==this._Store)return;this._sharedDoc.off("update",this._storeUpdate),this._sharedDoc.off("subdocs",this._manageSubDocs),this._sharedDoc.off("destroy",this.destroy),this.isSynced||(this._pendingUpdates=0,this.emit("sync-aborted",[this,1]));const t=null==this._SuperProvider?await this._StorageKeys():await this._StorageSubKeysFor(this._sharedDoc);let e=this._Store;this._Store=void 0;for(let s=0,i=t.length;s<i;s++)await e.removeItem(t[s])}async _applyStoredUpdates(){this._isBusy=!0;try{this._pendingUpdates=1;const e=null==this._SuperProvider?await this._StorageKeys():await this._StorageSubKeysFor(this._sharedDoc);if(this._pendingUpdates--,e.length>0){this._pendingUpdates+=e.length,this._reportProgress();for(let s=0,i=e.length;s<i;s++){if(null==this._Store)return;const i=await this._Store.getItem(e[s]);t.applyUpdate(this._sharedDoc,i,this),this._completedUpdates++,this._reportProgress()}this._sharedDoc.emit("load",[this])}else this._reportProgress()}catch(t){this._breakdownWith("could not restore document from persistence",t)}this._isBusy=!1,this._enqueuedUpdates.length>0&&this._storeUpdatesAndCompact()}_storeUpdate(t,e){null!=this._Store&&e!==this&&(this._pendingUpdates++,this._reportProgress(),this._enqueuedUpdates.push(t),this._isBusy||this._storeUpdatesAndCompact())}async _storeUpdatesAndCompact(){if(null==this._Store)return;this._isBusy=!0;const t=null==this._SuperProvider?await this._StorageKeys():await this._StorageSubKeysFor(this._sharedDoc);for(;null!=this._Store&&this._enqueuedUpdates.length>0;){try{if(await this._storeNextUpdateAmong(t),null==this._Store)return}catch(t){this._breakdownWith("could not persist document update",t)}if(t.length>=this._UpdateLimit)try{await this._compactUpdates(t)}catch(t){this._breakdownWith("could not compact document updates",t)}}this._isBusy=!1}async _storeNextUpdateAmong(t){let e=this._newUpdateKeyAmong(t);t.push(e),await this._Store.setItem(e,this._enqueuedUpdates[0]),this._enqueuedUpdates.shift(),this._completedUpdates++,this._reportProgress()}async _compactUpdates(e){const s=this._enqueuedUpdates.length>0;this._pendingUpdates-=this._enqueuedUpdates.length,this._enqueuedUpdates=[];let i=this._newUpdateKeyAmong(e);if(await this._Store.setItem(i,t.encodeStateAsUpdate(this._sharedDoc)),null!=this._Store){for(let t=0,s=e.length;t<s;t++)if(await this._Store.removeItem(e[t]),null==this._Store)return;e.splice(0,e.length,i),s&&this._reportProgress()}}_newUpdateKeyAmong(t){let e=(null==this._SuperProvider?"":this._sharedDoc.guid)+"@"+Date.now(),s=0,i=e+"-"+s;for(;t.indexOf(i)>=0;)s++,i=e+"-"+s;return i}async _removeStoredSubDoc(t){let e=await this._StorageSubKeysFor(t);try{for(let t=0,s=e.length;t<s;t++)if(await this._Store.removeItem(e[t]),null==this._Store)return}catch(e){this._breakdownWith("could not remove persistence for subdoc "+t.guid,e)}}_breakdown(){this._Store=void 0,this._isBusy=!1,this.isSynced||(this._enqueuedUpdates=[],this._pendingUpdates=0,this.emit("sync-aborted",[this,1])),this._SubDocMap.forEach(t=>t._breakdown())}_breakdownWith(t,e){throw this._breakdown(),new Error(t+(null==e?"":", reason: "+e))}async _manageSubDocs(t){const e=t=>{if(!this._SubDocMap.has(t)&&this._sharedDoc.guid!==t.guid){const e=new s(this._Store,t,this._UpdateLimit,this);this._SubDocMap.set(t,e)}},{removed:i,loaded:r}=t;if(null!=i){let t=Array.from(i.values());for(let e=0,s=t.length;e<s;e++){const s=t[e],i=this._SubDocMap.get(s);null!=i&&i._breakdown(),this._SubDocMap.delete(s),null!=this._sharedDoc&&this._sharedDoc.guid!==s.guid&&Array.from(this._sharedDoc.getSubdocs().values()).every(t=>t.guid!==s.guid)&&await this._removeStoredSubDoc(s)}}null!=r&&r.forEach(t=>{e(t)})}_reportProgress(){switch(!0){case 0===this._pendingUpdates:this._completedUpdates=0,this.emit("synced",[this]),this._sharedDoc.emit("sync",[this]),null!=this._SuperProvider&&this._SuperProvider.emit("subdoc-synced",[this,this._sharedDoc]);break;case 0===this._completedUpdates&&1===this._pendingUpdates:this.emit("sync-started",[this,0]);break;case this._completedUpdates===this._pendingUpdates:this.emit("sync-finished",[this,1]),this._pendingUpdates=this._completedUpdates=0,this.emit("synced",[this]),this._sharedDoc.emit("sync",[this]),null!=this._SuperProvider&&this._SuperProvider.emit("subdoc-synced",[this,this._sharedDoc]);break;default:this.emit("sync-continued",[this,this._completedUpdates/this._pendingUpdates])}}async _StorageKeys(){return(await this._Store.keys()).filter(t=>t.startsWith("@"))}async _StorageSubKeys(){return(await this._Store.keys()).filter(t=>!t.startsWith("@"))}async _StorageSubKeysFor(t){const e=t.guid+"@";return(await this._Store.keys()).filter(t=>t.startsWith(e))}}export{s as LocalForageProvider};
//# sourceMappingURL=y-localforage.modern.js.map
