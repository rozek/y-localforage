{"version":3,"file":"y-localforage.modern.js","sources":["../src/y-localforage.ts"],"sourcesContent":["import * as Y         from 'yjs'\nimport { Observable } from 'lib0/observable'\n\n// Store Key Pattern: [<subdoc-guid>]@<timestamp>-<n>\n\n//namespace LocalForageProvider {\n  const GUIDPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}@/i\n\n  type SubDocChanges = {\n    added:Set<Y.Doc>, removed:Set<Y.Doc>, loaded:Set<Y.Doc>\n  }\n\n  export class LocalForageProvider extends Observable<any> {\n    private _Store:any\n    private _sharedDoc:Y.Doc\n    private _SuperProvider?:LocalForageProvider\n\n    private _isBusy:boolean  = false\n    private _UpdateLimit:number = 500\n\n    private _pendingUpdates:number   = 0\n    private _completedUpdates:number = 0\n\n    private _enqueuedUpdates:Uint8Array[] = []\n\n    private _SubDocMap:Map<Y.Doc,LocalForageProvider> = new Map()\n\n    constructor (\n      Store:any, sharedDoc:Y.Doc, UpdateLimit:number = 500,\n      SuperProvider?:LocalForageProvider\n    ) {\n      super()\n\n      this._Store         = Store\n      this._sharedDoc     = sharedDoc\n      this._SuperProvider = SuperProvider\n\n      this._isBusy      = false\n      this._UpdateLimit = UpdateLimit\n\n      this._storeUpdate = this._storeUpdate.bind(this)\n      sharedDoc.on('update', this._storeUpdate)\n\n      this._manageSubDocs = this._manageSubDocs.bind(this)\n      sharedDoc.on('subdocs', this._manageSubDocs)\n\n      this.destroy = this.destroy.bind(this)\n      sharedDoc.on('destroy', this.destroy)\n\n      this._applyStoredUpdates()     // is safe, even while updated or destroyed\n    }\n\n  /**** isSynced - is true while this provider and its sharedDoc are in-sync ****/\n\n    get isSynced ():boolean {\n      return (this._pendingUpdates === 0)\n    }\n\n  /**** isFullySynced - is true while this._sharedDoc and all subdocs are in-sync ****/\n\n    get isFullySynced ():boolean {\n      return (\n        (this._pendingUpdates === 0) &&\n        Array.from(this._SubDocMap.values()).every(\n          (SubProvider) => SubProvider.isSynced\n        )\n      )\n    }\n\n  /**** SubDocIsSynced - is true while the given SubDoc is in-sync ****/\n\n    public SubDocIsSynced (SubDoc:Y.Doc):boolean {\n      const SubDocProvider = this._SubDocMap.get(SubDoc)\n      return (SubDocProvider != null) && SubDocProvider.isSynced\n    }\n\n  /**** destroy - destroys persistence, invalidates provider ****/\n\n    async destroy ():Promise<void> {\n      if (this._Store == null) { return }         // provider has been destroyed\n\n      this._sharedDoc.off('update',  this._storeUpdate)\n      this._sharedDoc.off('subdocs', this._manageSubDocs)\n      this._sharedDoc.off('destroy', this.destroy)\n\n      if (! this.isSynced) {\n        this._pendingUpdates = 0\n        this.emit('sync-aborted',[this,1.0])\n      }\n\n      const KeysToDelete = (\n        this._SuperProvider == null\n        ? await this._StorageKeys()\n        : await this._StorageSubKeysFor(this._sharedDoc)\n      )\n\n      let Store = this._Store\n// @ts-ignore allow clearing of \"this._Store\"\n      this._Store = undefined\n\n      for (let i = 0, l = KeysToDelete.length; i < l; i++) {\n        await Store.removeItem(KeysToDelete[i])\n      }\n    }\n\n  /**** _applyStoredUpdates - applies all stored (incremental) updates to sharedDoc ****/\n\n    private async _applyStoredUpdates ():Promise<void> {\n      this._isBusy = true        // prevents update entries from being persisted\n        try {\n          this._pendingUpdates = 1 // very bad trick to keep this.isSynced false\n            const UpdateKeys = (\n              this._SuperProvider == null\n              ? await this._StorageKeys()\n              : await this._StorageSubKeysFor(this._sharedDoc)\n            )\n          this._pendingUpdates--                  // compensate trick from above\n\n          if (UpdateKeys.length > 0) {\n            this._pendingUpdates += UpdateKeys.length; this._reportProgress()\n\n            for (let i = 0, l = UpdateKeys.length; i < l; i++) {\n              if (this._Store == null) { return } // provider has been destroyed\n\n              const Update = await this._Store.getItem(UpdateKeys[i])\n              Y.applyUpdate(this._sharedDoc, Update, this)\n                                          // updates can be applied in any order\n              this._completedUpdates++; this._reportProgress()\n            }\n            this._sharedDoc.emit('load',[this])         // resolves \"whenLoaded\"\n          } else {\n            this._reportProgress()\n          }\n        } catch (Signal:any) {\n          this._breakdownWith(\n            'could not restore document from persistence', Signal\n          )\n        }\n      this._isBusy = false              // allows update entries to be persisted\n\n      if (this._enqueuedUpdates.length > 0) {\n        this._storeUpdatesAndCompact()\n      }\n    }\n\n  /**** _storeUpdate - stores a given (incremental) update ****/\n\n    private _storeUpdate (Update:Uint8Array, Origin?:any):void {\n      if (this._Store == null) { return }         // provider has been destroyed\n\n      if (Origin !== this) {          // ignore updates applied by this provider\n        this._pendingUpdates++; this._reportProgress()\n\n        this._enqueuedUpdates.push(Update)\n        if (! this._isBusy) {\n          this._storeUpdatesAndCompact()\n        }            // never write (and compact!) multiple updates concurrently\n      }\n    }\n\n  /**** _storeUpdatesAndCompact - stores enqueued updates and compacts ****/\n\n    private async _storeUpdatesAndCompact ():Promise<void> {\n      if (this._Store == null) { return }         // provider has been destroyed\n\n      this._isBusy = true\n        const UpdateKeys = (\n          this._SuperProvider == null\n          ? await this._StorageKeys()\n          : await this._StorageSubKeysFor(this._sharedDoc)\n        )\n\n        while ((this._Store != null) && (this._enqueuedUpdates.length > 0)) {\n          try {\n            await this._storeNextUpdateAmong(UpdateKeys)\n            if (this._Store == null) { return }   // provider has been destroyed\n          } catch (Signal) {\n            this._breakdownWith(\n              'could not persist document update', Signal\n            )\n          }\n\n          if (UpdateKeys.length >= this._UpdateLimit) {\n            try {\n              await this._compactUpdates(UpdateKeys)\n            } catch (Signal) {\n              this._breakdownWith(\n                'could not compact document updates', Signal\n              )\n            }\n          }\n        }\n      this._isBusy = false\n    }\n\n  /**** _storeNextUpdateAmong - stores next enqueued updates ****/\n\n    private async _storeNextUpdateAmong (UpdateKeys:string[]):Promise<void> {\n      let UpdateKey:string = this._newUpdateKeyAmong(UpdateKeys)\n      UpdateKeys.push(UpdateKey)\n\n      await this._Store.setItem(UpdateKey,this._enqueuedUpdates[0])\n\n      this._enqueuedUpdates.shift()\n      this._completedUpdates++; this._reportProgress()\n    }\n\n  /**** _compactUpdates - compacts the given list of updates ****/\n\n    private async _compactUpdates (UpdateKeys:string[]):Promise<void> {\n      const thisHadEnqueuedUpdates = (this._enqueuedUpdates.length > 0)\n        this._pendingUpdates -= this._enqueuedUpdates.length\n        this._enqueuedUpdates = []      // all enqueued updates will be included\n\n        let CompactKey:string = this._newUpdateKeyAmong(UpdateKeys)\n\n        await this._Store.setItem(CompactKey,Y.encodeStateAsUpdate(this._sharedDoc))\n        if (this._Store == null) { return }       // provider has been destroyed\n\n        for (let i = 0, l = UpdateKeys.length; i < l; i++) {\n          await this._Store.removeItem(UpdateKeys[i])\n          if (this._Store == null) { return }     // provider has been destroyed\n        }\n\n        UpdateKeys.splice(0,UpdateKeys.length, CompactKey)\n      if (thisHadEnqueuedUpdates) { this._reportProgress() }\n    }\n\n  /**** _newUpdateKeyAmong - generates a new unique update key ****/\n\n    private _newUpdateKeyAmong (UpdateKeys:string[]):string {\n      let KeyBase:string = (\n        (this._SuperProvider == null ? '' : this._sharedDoc.guid) + '@' + Date.now()\n      ), KeySuffix:number = 0\n        let UpdateKey:string = KeyBase + '-' + KeySuffix\n        while (UpdateKeys.indexOf(UpdateKey) >= 0) {\n          KeySuffix++\n          UpdateKey = KeyBase + '-' + KeySuffix\n        }\n      return UpdateKey\n    }\n\n  /**** _removeStoredSubDoc - removes a single stored subdoc ****/\n\n    private async _removeStoredSubDoc (SubDoc:Y.Doc):Promise<void> {\n      let KeysToDelete = await this._StorageSubKeysFor(SubDoc)\n      try {\n        for (let i = 0, l = KeysToDelete.length; i < l; i++) {\n          await this._Store.removeItem(KeysToDelete[i])\n          if (this._Store == null) { return }     // provider has been destroyed\n        }\n      } catch (Signal) {\n        this._breakdownWith(\n          'could not remove persistence for subdoc ' + SubDoc.guid, Signal\n        )\n      }\n    }\n\n  /**** _breakdown - breaks down this provider ****/\n\n    private _breakdown ():void {\n// @ts-ignore allow clearing of \"this._Store\"\n      this._Store = undefined\n\n      this._isBusy = false\n\n      if (! this.isSynced) {\n        this._enqueuedUpdates = []\n        this._pendingUpdates  = 0\n        this.emit('sync-aborted',[this,1.0])\n      }\n\n      this._SubDocMap.forEach((Provider) => Provider._breakdown())\n    }\n\n  /**** _breakdownWith - breaks down this provider after failure ****/\n\n    private _breakdownWith (Message:string, Reason?:any):never {\n      this._breakdown()\n\n      throw new Error(\n        Message + (Reason == null ? '' : ', reason: ' + Reason)\n      )\n    }\n\n  /**** _manageSubDocs - manages subdoc persistences ****/\n\n    private async _manageSubDocs (Changes:SubDocChanges):Promise<void> {\n      const providePersistenceFor = (SubDoc:Y.Doc) => {\n        if (\n          ! this._SubDocMap.has(SubDoc) &&\n          (this._sharedDoc.guid !== SubDoc.guid)     // \"doc copies\" are strange\n        ) {\n          const SubDocProvider = new LocalForageProvider(\n            this._Store, SubDoc, this._UpdateLimit, this\n          )\n          this._SubDocMap.set(SubDoc,SubDocProvider)\n        }\n      }\n\n      const { added, removed, loaded } = Changes\n\n      if (removed != null) {\n        let SubDocList:Y.Doc[] = Array.from(removed.values())\n        for (let i = 0, l = SubDocList.length; i < l; i++) {\n          const SubDoc = SubDocList[i]\n\n          const Provider = this._SubDocMap.get(SubDoc)\n          if (Provider != null) { Provider._breakdown() }\n\n          this._SubDocMap.delete(SubDoc)\n\n          if (\n            (this._sharedDoc != null) &&          // \"doc copies\" are strange...\n            (this._sharedDoc.guid !== SubDoc.guid) &&\n            Array.from(this._sharedDoc.getSubdocs().values()).every(\n              (existingSubDoc) => (existingSubDoc.guid !== SubDoc.guid)\n            )                                                       // ...really\n          ) {\n            await this._removeStoredSubDoc(SubDoc)\n          }  // warning: pot. race condition if \"guid\" is immediately used again\n        }\n      }\n\n      if (loaded != null) {\n        loaded.forEach((SubDoc:Y.Doc) => {\n          providePersistenceFor(SubDoc)\n        })\n      }\n    }\n\n  /**** _reportProgress - emits events reporting synchronization progress ****/\n\n    private _reportProgress ():void {\n      switch (true) {\n        case (this._pendingUpdates === 0):\n          this._completedUpdates = 0\n          this.emit('synced',[this])\n          this._sharedDoc.emit('sync',[this])     // resolves \"whenSynced\", once\n\n          if (this._SuperProvider != null) {\n            this._SuperProvider.emit('subdoc-synced',[this,this._sharedDoc])\n          }\n          break\n        case (this._completedUpdates === 0) && (this._pendingUpdates === 1):\n          this.emit('sync-started',[this,0.0])\n          break\n        case (this._completedUpdates === this._pendingUpdates):\n          this.emit('sync-finished',[this,1.0])\n\n          this._pendingUpdates = this._completedUpdates = 0\n          this.emit('synced',[this])\n          this._sharedDoc.emit('sync',[this])     // resolves \"whenSynced\", once\n\n          if (this._SuperProvider != null) {\n            this._SuperProvider.emit('subdoc-synced',[this,this._sharedDoc])\n          }\n          break\n        default:\n          const Progress = this._completedUpdates/this._pendingUpdates\n          this.emit('sync-continued',[this,Progress])\n      }\n    }\n\n  /**** _StorageKeys - lists all keys used for sharedDoc itself ****/\n\n    private async _StorageKeys ():Promise<string[]> {\n      let StoreKeys:string[] = await this._Store.keys()\n      return StoreKeys.filter((Key) => Key.startsWith('@'))\n    }\n\n  /**** _StorageSubKeys - lists all keys used for subdocs of sharedDoc ****/\n\n    private async _StorageSubKeys ():Promise<string[]> {\n      let StoreKeys:string[] = await this._Store.keys()\n      return StoreKeys.filter((Key) => ! Key.startsWith('@'))\n    }\n\n  /**** _StorageSubKeysFor - lists all keys used for a given subdoc ****/\n\n    private async _StorageSubKeysFor (SubDoc:Y.Doc):Promise<string[]> {\n      const KeyPrefix = SubDoc.guid + '@'\n\n      let StoreKeys:string[] = await this._Store.keys()\n      return StoreKeys.filter((Key) => Key.startsWith(KeyPrefix))\n    }\n  }\n//}\n"],"names":["LocalForageProvider","Observable","constructor","Store","sharedDoc","UpdateLimit","SuperProvider","super","this","_Store","_sharedDoc","_SuperProvider","_isBusy","_UpdateLimit","_pendingUpdates","_completedUpdates","_enqueuedUpdates","_SubDocMap","Map","_storeUpdate","bind","on","_manageSubDocs","destroy","_applyStoredUpdates","isSynced","isFullySynced","Array","from","values","every","SubProvider","SubDocIsSynced","SubDoc","SubDocProvider","get","off","emit","KeysToDelete","_StorageKeys","_StorageSubKeysFor","undefined","i","l","length","removeItem","UpdateKeys","_reportProgress","Update","getItem","Y","applyUpdate","Signal","_breakdownWith","_storeUpdatesAndCompact","Origin","push","_storeNextUpdateAmong","_compactUpdates","UpdateKey","_newUpdateKeyAmong","setItem","shift","thisHadEnqueuedUpdates","CompactKey","encodeStateAsUpdate","splice","KeyBase","guid","Date","now","KeySuffix","indexOf","_removeStoredSubDoc","_breakdown","forEach","Provider","Message","Reason","Error","Changes","providePersistenceFor","has","set","removed","loaded","SubDocList","delete","getSubdocs","existingSubDoc","keys","filter","Key","startsWith","_StorageSubKeys","KeyPrefix"],"mappings":"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"}